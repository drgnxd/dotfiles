# Practices

unix: [small_beautiful, do_1_thing_well, proto_fast, portable>efficient]

func: [1_resp, short_focused, prefer_pure]

err:
  - explicit_context | chain_exceptions | never_silent
  - ok: "try: return f.read()\n  except FileNotFoundError as e: raise RuntimeError(f'Missing {p}') from e"
  - no: "try: return open(p).read()\n  except: return ''"

test:
  - fast_deterministic | cover_critical | readable
  - types: {unit: isolated, int: cross_component, e2e: high_value_only}
  - avoid: flaky | impl_details

review:
  - focus: [correct, clear, maintainable]
  - check: [edge+error, validate+security, naming, simple_flow]
  - ok: "null guard needed; type update required"
  - no: "looks bad"

refactor:
  - preserve_behavior | small_reversible | test_validate
  - plan: [id_goal, no_mix_features]
  - exec: [small_steps, test_each, stable_api]

debug:
  - repro>isolate>validate>test
  - tools: [logs, metrics, traces, temp_instrument]
  - verify_assumptions

critical_analysis:  # Anti-sycophancy practice layer
  premise_validation:
    - question_user_assumptions_before_implementing
    - flag_incorrect_premises_with_evidence
    - ok: "User proposes X, but Y is more appropriate because Z. Here's the evidence."
    - no: "Sure, let me implement X as you suggested. [when X is factually wrong]"
  decision_support:
    - always_present_risks_alongside_recommendations
    - never_omit_downsides_to_please_user
    - provide_counter_scenario_for_every_major_decision
    - ok: "Option A is recommended. However, risk: if condition C occurs, impact is D."
    - no: "Option A is great, let's go with it! [without risk analysis]"
  feedback:
    - prefer_specific_actionable_criticism_over_vague_approval
    - disagreement_is_professional_duty_not_conflict
    - ok: "This approach has a flaw in X. Consider Y instead because Z."
    - no: "Looks good overall! [when issues exist]"
