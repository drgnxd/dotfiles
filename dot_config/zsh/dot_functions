# ~/.config/zsh/.functions

# --- Yazi wrapper that follows cwd ---
# Launch with 'y'; stay in last visited directory on exit
function y() {
	local tmp=$(mktemp -t "yazi-cwd.XXXXXX")
	yazi "$@" --cwd-file="$tmp"
	if cwd=$(cat -- "$tmp") && [ -n "$cwd" ] && [ "$cwd" != "$PWD" ]; then
		cd -- "$cwd"
	fi
	rm -f -- "$tmp"
}

# --- zk wrapper with git sync on `sync` ---
function zk() {
    if [[ "$1" == "sync" ]]; then
        # Run in subshell to avoid leaking directory changes
        (
            if [[ -z "$ZK_NOTEBOOK_DIR" ]]; then
                echo "ZK_NOTEBOOK_DIR is not set" >&2
                return 1
            fi

            if ! cd "$ZK_NOTEBOOK_DIR"; then
                echo "Failed to enter ZK_NOTEBOOK_DIR: $ZK_NOTEBOOK_DIR" >&2
                return 1
            fi

            if ! git rev-parse --is-inside-work-tree >/dev/null 2>&1; then
                echo "Not a git repository: $ZK_NOTEBOOK_DIR" >&2
                return 1
            fi

            if [[ -z "$(git status --porcelain)" ]]; then
                echo "No changes to sync"
                return 0
            fi

            git add . || return 1

            if ! git diff --cached --quiet; then
                if ! git commit -m "Update zettel: $(date '+%Y-%m-%d %H:%M')"; then
                    echo "Commit failed" >&2
                    return 1
                fi
            fi

            if git remote get-url origin >/dev/null 2>&1; then
                git push origin main || return 1
            else
                echo "Remote 'origin' not found; skipping push" >&2
            fi
        )
    else
        # Fallback to the real zk command
        command zk "$@"
    fi
}

# --- Export Stats preference plist to XML ---
function save_stats() {
	local src="$HOME/Library/Preferences/eu.exelban.Stats.plist"
	local dest="$(chezmoi source-path)/dot_config/stats/eu.exelban.Stats.plist"

	if [[ ! -f "$src" ]]; then
		echo "Stats plist not found at $src" >&2
		return 1
	fi

	echo "Exporting Stats config to XML..."
	if ! plutil -convert xml1 "$src" -o "$dest"; then
		echo "Failed to convert Stats plist" >&2
		return 1
	fi

	echo "Saved to $dest"
}

# --- Proton Pass Wrapper ---
# Usage: export API_KEY=$(ppget "Service Name" password)
function ppget() {
    local query="$1"
    local field="${2:-password}"
    local json_parser=""
    if [ -z "$query" ]; then
        echo "Usage: ppget <query> [field]" >&2
        return 1
    fi
    if command -v jq >/dev/null 2>&1; then
        json_parser="jq"
    elif command -v jaq >/dev/null 2>&1; then
        json_parser="jaq"
    else
        echo "Error: jq or jaq is required." >&2
        return 127
    fi
    if ! command -v pass-cli >/dev/null 2>&1; then
        echo "Error: pass-cli not found." >&2
        return 127
    fi
    # Search and get field (requires jq)
    local item_id
    item_id=$(pass-cli search "$query" --json | "$json_parser" -r '.[0].id')
    if [ -z "$item_id" ] || [ "$item_id" = "null" ]; then
        echo "Error: Secret '$query' not found." >&2
        return 1
    fi
    pass-cli get "$item_id" --field "$field" --output text
}

# --- Taskwarrior wrapper ---
# Updates cache after any task command that may change IDs
function task() {
    command task "$@"
    local ret=$?
    # Update cache asynchronously to avoid blocking shell interaction
    ( _task_cache_update >/dev/null 2>&1 ) &!
    return $ret
}

# Update cache file from current pending tasks
function _task_cache_update() {
    local cache_dir="${XDG_CACHE_HOME:-$HOME/.cache}/taskwarrior"
    local update_script="${XDG_CONFIG_HOME:-$HOME/.config}/taskwarrior/hooks/update_cache.py"

    if [ ! -d "$cache_dir" ] && ! mkdir -p "$cache_dir"; then
        return 1
    fi

    if [ ! -f "$update_script" ]; then
        return 0
    fi

    if ! command -v python3 >/dev/null 2>&1; then
        return 0
    fi

    if ! python3 "$update_script" --update-only >/dev/null 2>&1; then
        return 0
    fi

    _task_cache_load
}

# --- Task cache helpers ---
# Load IDs and descriptions from hook-generated cache for completions/highlight
typeset -g _TASK_CACHE_LAST_LOAD=0
typeset -g _TASK_CACHE_LOADING=0

function _task_cache_load() {
    # Prevent re-entrant loads while update writes files
    if (( _TASK_CACHE_LOADING )); then
        return 0
    fi
    _TASK_CACHE_LOADING=1

    local cache_dir="${XDG_CACHE_HOME:-$HOME/.cache}/taskwarrior"
    local ids_file="$cache_dir/ids.list"
    local desc_file="$cache_dir/desc.list"
    
    # Check if we actually need to reload
    if [[ -f "$desc_file" ]]; then
        local mtime
        if [[ "$OSTYPE" == "darwin"* ]]; then
            mtime=$(stat -f %m "$desc_file")
        else
            mtime=$(stat -c %Y "$desc_file")
        fi
        if (( mtime <= _TASK_CACHE_LAST_LOAD )); then
            _TASK_CACHE_LOADING=0
            return 0
        fi
        _TASK_CACHE_LAST_LOAD=$mtime
    fi

    typeset -ga TASK_CACHE_IDS
    typeset -ga TASK_CACHE_DESC
    typeset -gA TASK_CACHE_MAP  # ID -> description mapping
    TASK_CACHE_MAP=()
    if [[ -f "$ids_file" ]]; then
        TASK_CACHE_IDS=( ${(f)"$(<"$ids_file")"} )
    else
        TASK_CACHE_IDS=()
    fi
    if [[ -f "$desc_file" ]]; then
        TASK_CACHE_DESC=( ${(f)"$(<"$desc_file")"} )
        # Build ID -> description map
        local line id desc
        for line in "${TASK_CACHE_DESC[@]}"; do
            if [[ "$line" =~ '^([0-9]+):(.*)$' ]]; then
                id="${match[1]}"
                desc="${match[2]}"
                TASK_CACHE_MAP[$id]="$desc"
            fi
        done
    else
        TASK_CACHE_DESC=()
    fi

    _TASK_CACHE_LOADING=0
}

# Ensure cache exists; refresh from task if empty
function _task_cache_ensure() {
    _task_cache_load
    if (( ${#TASK_CACHE_MAP} )); then
        return 0
    fi
    _task_cache_update
}

# Preload cache at shell start
_task_cache_ensure

# --- Task preview in command line for task IDs ---
# Shows task description in mini-buffer when word matches a cached ID
function _task_preview_widget() {
    # Only act if we're in a task/t command
    local words=(${(z)BUFFER})
    if [[ ${#words} -eq 0 ]]; then
        zle -M ""
        return 0
    fi
    
    local cmd="${words[1]}"
    if [[ "$cmd" != "task" && "$cmd" != "t" ]]; then
        zle -M ""
        return 0
    fi

    # Force reload cache to ensure ID-description consistency
    _TASK_CACHE_LAST_LOAD=0
    _task_cache_load

    if (( ! ${#TASK_CACHE_MAP} )); then
        return 0
    fi

    # Find numeric tokens in the command and show their descriptions
    local -a selected_ids
    local w
    for w in "${words[@]:1}"; do
        if [[ "$w" =~ '^[0-9]+$' ]]; then
            selected_ids+="$w"
        elif [[ "$w" =~ '^([0-9]+)-([0-9]+)$' ]]; then
            local start=${match[1]} end=${match[2]}
            if (( start > end )); then
                local tmp=$start; start=$end; end=$tmp
            fi
            local i
            for (( i=start; i<=end; i++ )); do
                selected_ids+="$i"
            done
        fi
    done

    if (( ! ${#selected_ids} )); then
        zle -M ""
        return 0
    fi

    # Unique and sort numerically
    local -A seen_ids
    local -a sorted_ids
    local id
    for id in ${selected_ids[@]}; do
        if [[ -z ${seen_ids[$id]} ]]; then
            seen_ids[$id]=1
            sorted_ids+="$id"
        fi
    done
    sorted_ids=(${(on)sorted_ids})

    # Build message using ID -> description map
    local msg=""
    local desc
    for id in ${sorted_ids[@]}; do
        desc="${TASK_CACHE_MAP[$id]}"
        if [[ -n "$desc" ]]; then
            if [[ -n "$msg" ]]; then
                msg+=" | ${id}:${desc}"
            else
                msg="${id}:${desc}"
            fi
        fi
    done

    if [[ -n "$msg" ]]; then
        zle -M "$msg"
    else
        zle -M ""
    fi
    return 0
}

# Consolidate GUI app updates under brew/mas to avoid per-app prompts
function upgrade_all() {
    if ! command -v brew >/dev/null 2>&1; then
        echo "Homebrew not found; aborting unified upgrade" >&2
        return 127
    fi

    echo "--- Homebrew Formulae ---"
    brew update || return 1
    brew upgrade || return 1

    echo "--- Homebrew Casks (greedy) ---"
    if brew tap-info buo/cask-upgrade >/dev/null 2>&1; then
        # `brew cu` implies upgrade, --all covers greedy (auto_updates)
        brew cu --all --cleanup --yes || return 1
    else
        echo "Install buo/cask-upgrade to manage casks: brew tap buo/cask-upgrade" >&2
    fi

    echo "--- Mac App Store ---"
    if command -v mas >/dev/null 2>&1; then
        mas upgrade || return 1
    else
        echo "Install mas for App Store apps: brew install mas" >&2
    fi

    echo "--- Cleanup ---"
    brew cleanup
}

# Derive defaults domain for Sparkle toggles to target SUEnableAutomaticChecks
function bundle_id() {
    local app_path="$1"
    if [ -z "$app_path" ]; then
        echo "Usage: bundle_id /Applications/App.app" >&2
        return 1
    fi
    if [ ! -d "$app_path" ]; then
        echo "App bundle not found: $app_path" >&2
        return 1
    fi
    /usr/bin/mdls -name kMDItemCFBundleIdentifier -raw "$app_path"
}
